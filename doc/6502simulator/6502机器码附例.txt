 //addr :代表8位地址
addr16:代表16位地址   
data :立即数
//数据传送指令
//LDA--由存储器取数送入累加器 M→A
符号码格式   指令操作码 寻址方式 
LDA ($addr,X) A1       先变址X后间址 
LDA $addr     A5       零页寻址 
LDA #$data   A9       立即寻址 
LDA $addr16   AD       绝对寻址 
LDA ($addr),Y B1       后变址Y间址 
LDA $addr,X   B5       零页X变址 
LDA $addr16,Y B9       绝对Y变址 
LDA $addr16,X BD       绝对X变址 

//LDX--由存储器取数送入累加器 M→X

符号码格式   指令操作码 寻址方式 
LDX #$data   A2       立即寻址 
LDX $addr     A6       零页寻址 
LDX $addr16   AE       绝对寻址 
LDX $addr,Y   B6       零页Y变址 
LDX $addr16,Y BE       绝对Y变址 

//LDY--由存储器取数送入累加器 M→Y

符号码格式   指令操作码 寻址方式 
LDY #$data   A0       立即寻址 
LDY $addr     A4       零页寻址 
LDY $addr16   AC       绝对寻址 
LDY $addr,X   B4       零页X变址 
LDY $addr16,X BC       绝对X变址 

//STA--将累加器的内容送入存储器 A--M

符号码格式   指令操作码 寻址方式 
STA ($addr,X) 81       先变址X后间址 
STA $addr     85       零页寻址 
STA $addr16   8D       绝对寻址 
STA ($addr),Y 91       后变址Y间址 
STA $addr,X   95       零页X变址 
STA $addr16,Y 99       绝对Y变址 
STA $addr16,X 9D       绝对X变址 

//STX--将寄存器X的内容送入存储器 X--M

符号码格式   指令操作码 寻址方式 
STX $addr     86       零页寻址 
STX $addr16   8E       绝对寻址 
STX $addr,Y   96       零页Y变址 

//STY--将寄存器Y的内容送入存储器 Y--M

符号码格式   指令操作码 寻址方式 
STY $addr     84       零页寻址 
STY $addr16   8C       绝对寻址 
STY $addr,X   94       零页X变址 

//寄存器和寄存器之间的传送

符号码格式   指令操作码 寻址方式   指令作用 
TAX         AA       寄存器寻址 将累加器A的内容送入变址寄存器X 
TXA         8A       寄存器寻址 将变址寄存器X的内容送入累加器A 
TAY         A8       寄存器寻址 将累加器A的内容送入变址寄存器Y 
TYA         98       寄存器寻址 将变址寄存器Y的内容送入累加器A 
TSX         BA       寄存器寻址 将堆栈指针S的内容送入变址寄存器X 
TXS         9A       寄存器寻址 将变址寄存器X的内容送入堆栈指针S 
//addr :代表8位地址   addr16:代表16位地址   data :立即数

[算术运算指令]

1. ADC--累加器,存储器,进位标志C相加,结果送累加器A A+M+C→A 

符号码格式   指令操作码 寻址方式         周期 
ADC ($addr,X) 61       先变址X后间址       
ADC $addr   65       零页寻址 
ADC #$data   69       立即寻址 
ADC $addr16   6D       绝对寻址 
ADC ($addr),Y 71       后变址Y间址 
ADC $addr,X   75       零页X变址 
ADC $addr16,Y 79       绝对Y变址 
ADC $addr16,X 7D       绝对X变址 

注意:由于进位标志C页会参加运算,所以在做加法运算时,一般要在前面加指令 CLC,清除进位标志

例1: //两个8位数加法运算演示,目的是将寄存器A的内容加上地址2100的内容,结果送寄存器A

2000:LDA #$20   //立即数21送寄存器A
2002:STA $2100   //地址2100的内容为20
2005:LDA #$21   //寄存器A的内容为21
2007:CLC       //清除进位标志C,注意:在做加法运算前一定要加该指令
2008:ADC $2100   //寄存器A的内容和地址2100的内容相加
200B:RTS

大家可以进入NCTOOLS，输入 A 2000，然后输入上面代码，然后 输入 G 2000，然后按R看寄存器A的值，是不是等于41呢？

例2：//两个16位数加法运算，这里是将0194+01BA，大家注意看看程序与上面有什么不同.
在这个程序里,先将要相加的数分别放地址2100,2101,2102,2103,具体是这样的:2100:94 01 BA 01
然后先将地址2100的内容+地址2102的内容,结果送地址2104
再将地址2101的内+地址2103的内容,结果送地址2105
那么地址2104,2105的结果,就是两个16位数相加的结果,这里是034E

2000:LDA #$94   //立即数94送寄存器A
2002:STA $2100   //寄存器A的内容送地址2100
2005:LDA #$01   //立即数01送寄存器A
2007:STA $2101   //寄存器A的内容送地址210
200A:LDA #$BA   //立即数BA送寄存器A
200C:STA $2102   //寄存器A的内容送地址2102
200F:LDA #$01   //立即数01送寄存器A
2011:STA $2103   //寄存器A的内容送地址2103
2014:CLC       //清除进位标志,注意,开始做加法程序前,一定要清除进位标志
2015:LDA $2100   //地址2100的值送寄存器A
2018:ADC $2102   //寄存器A的内容 + 地址2102的内容 + C → A,这里C=0
201B:STA $2104   //寄存器A的内容送地址2104
201E:LDA $2101   //地址2101的内容送寄存器A
2021:ADC $2103   //寄存器A的内容 + 地址2103的内容 + C → A,这里C=1,请注意,这里没有用CLC指令
2024:STA $2105   //寄存器A的内容送地址2105
2027:RTS       //程序结束

  在这个程序里,最重要的就是为什么后面的加法指令前面没有用CLC指令,不是说在做加法前要用CLC指令吗?

但这里就不一样,由于在前面已经用了CLC指令,将C=0,做了一次加法运算后,会影响标志位C

  如果做完第一次加法运算后,C=0,那么说明没有产生进位,C还是等于0,所以没有必要再用CLC指令

  如果做完第一次加法运算后,C=1,那么说明产生了进位,如果再做第二次加法运算前,还使用CLC指令,那么计算的结果

就是错误的,我们来看 第一次运算后,(2104)=4E,如果第二次运算前使用CLC指令,那么01+01+00=02,最后的结果是这样的

(2104)=4E,(2105)=02,那么说明 0194+01BA=024E,我们口算都能知道这个结果是错误的,实际上由于第一次运算后,产生了进位

所以我们要把进位保留即01+01+(C)=01+01+01=03,所以实际的结果是(2104)=4E,(2105)=03

　
2. SBC--从累加器减去存储器和进位标志C,结果送累加器 A-M-C→A

符号码格式   指令操作码 寻址方式 
SBC ($addr,X) E1     先变址X后间址 
SBC $addr   E5     零页寻址 
SBC #$data   E9     立即寻址 
SBC $addr16   ED     绝对寻址 
SBC ($addr),Y F1     后变址Y间址 
SBC $addr,X   F5     零页X变址 
SBC $addr16,Y F9     绝对Y变址 
SBC $addr16,X FD     绝对X变址 

注意:由于在做减法运算时,进位标志C会参与运算，所以在做减法前要先加指令 SEC，置进位标志

例： //减法指令演示,目的是将寄存器A的内容减去地址2100的内容,结果送寄存器A

2000: LDA #$21   //立即数21送寄存器A
2002:STA $2100   //寄存器A的内容送地址2100
2005: LDA #$22   //立即数22送寄存器A
2007:SEC       //置位标志位C,注意:在做减法运算前一定要加该指令
2008:SBC $2100   //寄存器A的内容减去地址2100的内容
200B: RTS

大家可以进入NCTOOLS，输入 A 2000，然后输入上面代码，然后 输入 G 2000，然后按R看寄存器A的值，是不是等于01呢？

　
例2:   //求二进制数的平方根

    程序目的:将地址2100的内容求得其平方根后,结果送地址2101,为方便计算,这里假设地址2100的内容为整数,方根也取整数

例如 若(2100)=19     (十进制的25)
  结果(2101)=05
  若(2101)=65     (十进制的101)
  结果(2101)=0A
　

  求方根方法:我们知道任何整数都有如下性质:
  1 * 1 = 1
  2 * 2 = 1 + 3
  3 * 3 = 1 + 3 + 5
  4 * 4 = 1 + 3 + 5 + 7
  ......
  N * N=1 + 3 + 5 + ...... + (2N-1)
  那么,我们可以把一个正整数X = N * N连续减去奇数 1, 3, 5, 7......(2N-1)直到结果为0或者不够减为止,所减去奇数的个数
就是这个正整数的整数平方根.
  在下面的程序里,我们将目标数连续减去地址F0的内容
2000:LDA#$00   //初始化地址F0的内容为00
2002:STA $F0
2004:LDA $2100   //取目标数到寄存器A中
2007:SEC
2008:SBC $F0   //目标数减去地址F0的内容
200A:BCC $2016   //不够减转结束,结果在地址F0中
200C:INC $F0   //地址F0的内容加1,(06)为已减的奇数个数
200E:SBC $F0   //和前面的减法指令合起来正好减去了奇整数
2010:BEQ $2016   //减结果为0,转结束,结果在地址F0中
2012:BCS $2008   //减结果>0,继续减
2014:DEC $F0   //减结果<0,则从结果中扣除1
2016:LDA $F0
2018:STA $2101   //把最后结果送地址2101
201B:RTS



3. INC--存储器单元内容增1 M+1→M

符号码格式   指令操作码 寻址方式 
INC $addr   E6       零页寻址 
INC $addr16   EE       绝对寻址 
INC $addr,X   F6       零页X变址 
INC $addr16,X FE       绝对X变址 

这个指令应该很好理解吧,就是把某个地址的内容加1,当然我们也可以用加法指令把某个地址加1,但大家可以看到,这里的指令所占用字节少
执行速度也较快.请看下面的比较:

用加法指令把地址2100的内容加1
2000:LDA $2100
2003:CLC
2004:ADC #$01
2006:STA $2100
2009:RTS


所占字节数:10个

用上面的指令把地址2100的内容加1
2000:INC $2100
2003:RTS

所占字节数:4个

一比较,大家就能发现谁占了上风吧!在对某个地址进行加1运算时,应该用INC指令.


4. DEC--存储器单元内容减1 M-1→M

符号码格式   指令操作码 寻址方式 
DEC $addr   C6       零页寻址 
DEC $addr16   CE       绝对寻址 
DEC $addr,X   D6       零页X变址 
DEC $addr16,X DE       绝对X变址 

5. 寄存器X,Y加1减1

符号码格式 指令操作码 烟烫烫烫烫烫烫烫烫烫烫烫贪址方式 
INX     E8       隐含寻址 
DEX     CA       隐含寻址 
INY     C8       隐含寻址 
DEY     88       隐含寻址 
//addr :代表8位地址   addr16:代表16位地址   data :立即数

[逻辑运算指令]

1.AND--寄存器与累加器相与,结果送累加器 A∧M→A

符号码格式 指令操作码 寻址方式 
AND ($addr,X) 21 先变址X后间址 
AND $addr 25 零页寻址 
AND #$data 29 立即寻址 
AND $addr16 2D 绝对寻址 
AND ($addr),Y 31 后变址Y间址 
AND $addr,X 35 零页X变址 
AND $addr16,Y 39 绝对Y变址 
AND $addr16,X 3D 绝对X变址 

逻辑与的主要功能是对目的操作数的某些位置0,或测试某位的状态

例1: 屏蔽地址2100的高四位,即将地址2100的高四位清零

2000:LDA $2100
2003:AND #$7F   (7F转化为二进制:0000 1111)
2005:STA $2100
2008:RTS

  所以我们可以知道,我们要使地址2100的高四为为0,只要使操作数的高四位为0,低四位为1,即操作数为0000 1111

然后再把地址2100的内容送寄存器A,把A的内容和0000 1111进行逻辑与运算,那么寄存器A的高四位自然就为0,由于操作数

低四位为1,所以寄存器A的低四位不变.

　

例2: 测试地址2100的第2位的状态,如果第2位=0,那么把00送寄存器X,否则把01送寄存器X

2000:LDA $2100
2003:AND #$04   (04转化为二进制:0000 0100)
2005:CMP #$04
2007:BNE $200C
2009:LDX #$01
200B:RTS
200C:LDX #$00
200E:RTS

　
  在这个程序中,我们要测试第2位的状态,只要让它与 0000 0100 进行逻辑与运算,若第2位为0,那么结果一定为0

如果第二位为1,那么由于操作数的第2位也为1,所以结果为0000 0100,即十六进制的04,所以我们可以判断结果是不是04

如果是04,那么说明第2位为1,否则为0.

  随便说个笑话,我们数字电路的老师告诉我们这样的口诀记住逻辑与的用法,那就是 "见0出0,全1出1"

  

2.ORA--寄存器与累加器相或,结果送累加器 A∨M→A

符号码格式   指令操作码 寻址方式 
ORA ($addr,X) 01       先变址X后间址 
ORA $addr   05       零页寻址 
ORA #$data   09       立即寻址 
ORA $addr16   0D       绝对寻址 
ORA ($addr),Y 11       后变址Y间址 
ORA $addr,X   15       零页X变址 
ORA $addr16,Y 19       绝对Y变址 
ORA $addr16,X 1D       绝对X变址 

  先告诉大家哪个不登大雅之堂的口诀 "见1出1,全0出0"

  逻辑或的功能主要是对目的操作数的某些位置1

例1: 使地址2100的高4位置1

2000:LDA $2100
2003:ORA #$F0   (F0的二进制:1111 0000)
2005:STA $2100
2008:RTS

这里我就不解释为什么这样做了,大家可以想一下.

　

3.EOR--寄存器与累加器相异或,结果送累加器 A≮M→A

符号码格式   指令操作码 寻址方式 
EOR ($addr,X) 41       先变址X后间址 
EOR $addr   45       零页寻址 
EOR #$data   49       立即寻址 
EOR $addr16   4D       绝对寻址 
EOR ($addr),Y 51       后变址Y间址 
EOR $addr,X   55       零页X变址 
EOR $addr16,Y 59       绝对Y变址 
EOR $addr16,X 5D       绝对X变址 

先告诉大家哪个不登大雅之堂的口诀 "相同出0,不同出1"

异或的功能主要就是求补码,加密等.

例1: 求地址2100的内容的反码

2000:LDA $2100
2003:EOR #$FF
2005:STA $2100
2008:RTS

  先说明下异或是怎么回事,什么是 "相同出0,不同出1"

  这里我们要把立即数7F,40进行异或运算,过程是这样的

  1.先把7F,40转化为二进制形式

  2.然后如果相同的位的值都不相同,那么该位为1,否则为0

(HEX) 7F (BIN) 0 1 1 1 1 1 1 1 (EOR)

------------------------

(HEX) 40 (BIN) 0 1 0 0 0 0 0 0

(HEX) 3F (BIN) 0 0 1 1 1 1 1 1

　

  所以我们要求反码,只要将该数和FF进行异或运算就可以了.

　

例2: 把地址3000-30FF的数据加密与解密

  先说明下为什么异或运算可以对数据进行加密,异或运算有一个特性:

  一个操作数(这里设为D1),和另外一个操作数(这里设为D2)进行异或运算,结果为D3

  表达式是这样的 D1 EOR D2 = D3

  然后如果我们将D3 再和D2进行异或运算,结果一定为D1,这就是加密的依据.

  所以我们要对某段数据进行加密时,只要使改段数据均和某个数进行异或运算,解密时再把加密的数据再和该数进行

异或运算即可,这里的某个数我们成为密匙,也就是说,一个人要解密,他必须得到密匙才能解密.

  当然实际运用时,我们可以搞的稍微复杂些,就比如下面的例子,以寄存器X的内容作为对象进行异或.

　

  加密程序如下:

2000:LDX #$50     //这里50就是密匙,不过这里的密匙不是不变的,每异或一次就加1
2002:LDY #$00     //计数器Y初始化为00
2004:INX         //寄存器X的内容加1,即每异或一次,寄存器X的内容就加1
2005:TXA         //寄存器X的内容发送给寄存器A
2007:EOR $3000,Y   //寄存器A的内容和地址[3000+Y]的内容进行异或运算
200A:STA $3000,Y   //结果仍然送回原地址
200D:INY         //计数器Y的值加1
200E:BNE $2004     //当全部加密完,程序结束,否则继续
2010:RTS

  

  解密程序如下:

2100:LDX #$50   //解密时,必须知道加密时X寄存器的初值,否则无法解密
2102:LDY #$00   //计数器Y初始化为00
2104:INX       //寄存器X的内容加1,即每异或一次,寄存器X的内容就加1
2105:LDA $3000,Y //地址[3000+Y]的内容送寄存器A
2108:STX $F0   //X寄存器的内容送地址F0,为下面的指令做好准备,因为没有和寄存器X进行异或运算的指令
210A:EOR $F0   //寄存器A的内容和地址F0即寄存器X的内容进行异或
210C:STA $3000,Y //结果送回原地址
210F:INY       //计数器Y的值加1 
2110:BNE $2104   //当全部解密完,程序结束,否则继续
2112:RTS

　
  由上面的程序可以知道,加密程序的密匙是可变的,但是变化规律很明显,就是一直加1,解密程序和加密程序几乎是一样的.

当然,这样的加密程序是不管用的,讲这个程序的目的只是抛砖引玉,为了说明EOR在加密中的运用.
//addr :代表8位地址   addr16:代表16位地址   data :立即数

[置标志位指令]

1. CLC--清除进位标志     0→C   机器码 18   √
2. SEC--置进位标志C       1→C   机器码 38   √
3. CLD--清除十进制运算标志D 0→D   机器码 D8   ×
4. SED--置十进制运算标志D   1→D   机器码 F8   ×
5. CLV--清除溢出标志V     0→V   机器码 B8
6. CLI--清除中断禁止指令I   0→I   机器码 58   √
7. SEI--置位中断禁止标志I   1→I   机器码 78   √

　

说明:上面的指令中,用的比较多的是指令 CLC,SEC,CLI,SEI,这些指令也没有什么好讲的

只是有两点要注意:

1.如果你在一个程序中用了 SEI 指令,那么程序结束前一定要用 CLI 指令,否则会死机.

2.指令 SED 在文曲星中似乎不能用,我每次用都会死机.也不知道是怎么回事,大家暂时也别用,CLD倒是可以用,不过好象没有用

的必要,所以这两条指令我看可以去掉.

//addr :代表8位地址   addr16:代表16位地址   data :立即数

//比较指令

1. CMP--累加器和存储器比较

符号码格式   指令操作码 寻址方式 
CMP ($addr,X) C1       先变址X后间址 
CMP $addr   C5       零页寻址 
CMP #$data   C9       立即寻址 
CMP $addr16   CD       绝对寻址 
CMP ($addr),Y D1       后变址Y间址 
CMP $addr,X   D5       零页X变址 
CMP $addr16,Y D9       绝对Y变址 
CMP $addr16,X DD       绝对X变址 

该指令也是做减法操作,将寄存器的内容减去存储器的内容,但它和减法指令有2点区别:

一是借位标志C不参加运算,所以在用CMP指令不必加指令SEC

二是减法的结果不送入寄存器A

该指令运行后,会影响标志位 C，Z，N.我们在实际中尤其要注意它是如何影响标志位C和标志位Z

若执行指令CMP后,C=1表示无借位,即A》M

若执行指令CMP后,C=0表示有借位,即A<M

若执行指令CMP后,Z=1表示A=M

从上面我们可以判断出A和M谁大谁小,或者A和M是不是相等

例：//比较指令演示,演示如何判断A和M的大小

2000:LDA $2100   //地址2100的内容送寄存器A
2003:CMP $2101   //寄存器A的内容和地址2101的内容相比较
2006:BEQ $2016   //若标志位Z=1,那么程序就跳转到地址2016
2008:BCC $2010   //若标志位C=0,那么程序就跳转到地址2010
200A:LDA #$02   //若进位标志C=1,程序不跳转,顺序执行
200C:STA $2102   //若程序执行到这里，说明C=1,那么将立即数02送地址2102，作为地址2100的值>地址2101的值的标志
200F:RTS
2010:LDA #$01   //若标志位C=0，那么将立即数01送地址2102，作为地址2100的值<地址2101的值的标志
2012:STA $2102
2015:RTS
2016:LDA #$00   //若标志位Z=1，那么将立即数00送地址2102，作为地址2100的值=地址2101的值的标志
2018:STA $2102
201B:RTS

进入NCTOOLS,输入 A 2000,然后输入上面的程序,先用E命令 E 2100,输入0102,然后G 2000,然后看地址2102的值

这里因为(2100)=01,(2101)=02,显然01>02那么程序执行后,(2102)=02,你可以用D 2102,看看是不是这样.

你也可以输入别的数值,看看地址2102的内容是不是和预期的一样.

　

2. CPX--寄存器X的内容和存储器比较

符号码格式 指令操作码 寻址方式 
CPX #$data E0       立即寻址 
CPX $addr   E4       零页寻址 
CPX $addr16 EC       绝对寻址 

这些指令和CMP指令相似,不过前者是寄存器A,后者是寄存器X,另外寻址方式也比较少.

这条指令用的比较多,特别是在循环时

例： //CPX在循环程序中的运用,该程序实现了将地址3000-30FF的内容发送到地址3100-31FF

2000:LDX #$00   //初始化寄存器X的值,一开始（X）=0
2002:LDA $3000,X //地址[3000+X]的内容送寄存器A
2005:STA $3100,X //寄存器A的内容送地址[3100+X]
2008:INX       //寄存器X的内容加1
2009:CPX #$00   //如果寄存器X的内容=00,那么说明数据已经发送完了.注意：FF+01=00
200B:BNE 2002   //程序跳转到地址2002继续发送直到寄存器X的内容=00
200D:RTS

这里我们来为初学者分析一下代码运行过程：

第1次循环   （X）=00   地址[3000+00]=3000的内容送地址[3100+00]=3100
第2次循环   (X) =01   地址[3000+01]=3001的内容送地址[3100+01]=3101
第3次循环   (X) =02   地址[3000+02]=3002的内容送地址[3100+02]=3102
....
....
第256次循环 (X) =FF   地址[3000+FF]=30FF的内容送地址[3100+FF]=31FF

3. CPY--寄存器Y的内容和存储器比较

符号码格式 指令操作码 寻址方式 
CPY #$data C0       立即寻址 
CPY $addr   C4       零页寻址 
CPY $addr16 CC       绝对寻址 

这些指令和CPX指令相似,不过前者是寄存器X,后者是寄存器Y.

　

4. BIT--位测试指令

符号码格式 指令操作码 寻址方式 
BIT $addr   24       零页寻址 
BIT $addr16 2C       绝对寻址 

这条指令的功能和AND指令有相同之处,那就是把累加器A同存储器单元相与,但和AND指令不同的是相与的结果不送入累加器A

另外该指令对标志位的影响也和AND指令不同

若 结果=0，那么Z=1

若 结果<>0,那么Z=0

N=M的第7位

V=M的第6位

所以执行该指令后N，V两标志位的状态就是参加与操作的存储单元的最高两位状态

这些指令在通讯程序中用的相当多，大家要给予足够的重视，是很有用的指令
//addr :代表8位地址   addr16:代表16位地址   data :立即数

//移位指令

1. 算术左移指令ASL

符号码格式   指令操作码 寻址方式 
ASL       0A       累加器寻址 
ASL $data   06       零页寻址 
ASL $addr16   0E       绝对寻址 
ASL $addr,X   16       零页X变址 
ASL $addr16,X 1E       绝对X变址 

ASL移位功能是将字节内各位依次向左移1位，最高位移进标志位C中，最底位补0

ASL执行结果相当于把移位前的数乘2

例如   //ASL的应用

2000:LDA #$20   //把立即数20送累加器A
2002:ASL     //累加器A的内容算术左移
2003:STA $2100 //把累加器A的内容送地址2100
2006:ASL $2100 //地址2100的内容算术左移
2009:LDA $2100 //地址2100的内容送累加器A
200C:RTS     //程序结束

2. 逻辑右移指令LSR

符号码格式   指令操作码 寻址方式 
LSR       4A       累加器寻址 
LSR $data   46       零页寻址 
LSR $addr16   4E       绝对寻址 
LSR $addr,X   56       零页X变址 
LSR $addr16,X 5E       绝对X变址 

该指令功能是将字节内各位依次向右移1位，最低位移进标志位C，最高位补0.

该操作对于无符号数和正数相当于乘1/2

例： //拆字程序，将地址2100单元的高四位送地址2101的低四位，将地址2100单元的低四位送地址2102的底四位

并且清除地址2101和地址2102的高四位

2000:LDA $2100 //地址2100的内容送A
2003:AND #$0F   //A和0F进行逻辑与运算，屏蔽了A的高四位
2005:STA $2102 //结果送地址2102
2008:LDA $2100       
200B:LSR     //将A的高四位挪到低四位，高四位补0
200C:LSR 
200D:LSR 
200E:LSR 
200F:STA $2101 //结果送地址2101
2012:RTS

3. 循环左移指令ROL

符号码格式   指令操作码 寻址方式 
ROL       2A       累加器寻址 
ROL $data   26       零页寻址 
ROL $addr16   2E       绝对寻址 
ROL $addr,X   36       零页X变址 
ROL $addr16,X 3E       绝对X变址 

ROL的移位功能是将字节内容连同进位C一起依次向左移1位

4. 循环右移指令ROR

符号码格式 指令操作码 寻址方式 
ROR       6A     累加器寻址 
ROR $data   66     零页寻址 
ROR $addr16   6E     绝对寻址 
ROR $addr,X   76     零页X变址 
ROR $addr16,X 7E     绝对X变址 

ROR的移位功能是将字节内容连同进位C一起依次向右移1位
//addr :代表8位地址   addr16:代表16位地址   data :立即数

//堆栈操作指令

1. 累加器进栈指令 PHA

  PHA是隐含寻址方式的单字节指令，操作码是 48

  功能是把累加器A的内容按堆栈指针S所指示的位置送入堆栈，然后堆栈指针减1

  该指令不影响标志寄存器P的状态

2. 累加器出栈指令 PLA

  PLA是隐含寻址方式的单字节指令，操作码是 68

  功能是先让堆栈指针S+1，然后取加过1的S所指向的单元的内容，把它送累加器A

  该指令影响标志寄存器P中的N，Z两标志位

3. 标志寄存器P进栈指令 PHP

  PHP是隐含寻址方式的单字节指令，操作码是 08

  功能是把标志寄存器P的内容按堆栈指针S所指示的位置送入堆栈，然后堆栈指针减1

  该指令不影响标志寄存器P的状态

4. 标志寄存器P出栈指令 PLP

  PLP是隐含寻址方式的单字节指令，操作码是 28

  功能是先让堆栈指针S+1，然后取加过1的S所指向的单元的内容，把它送标志寄存器P

5. 堆栈用法举例

  堆栈是一个存储区域,用来存放调用子程序或响应中断时的主程序断点,以及其他寄存器或存储器的内容.

  当主程序需要调用子程序时,有一组中间结果及标志位的状态需分别保留在寄存器和标志寄存器中

但被调用的子程序执行时,也需要占用这些寄存器并影响标志寄存器,这样除了在执行调用指令时将断点

(调用指令后紧接着的一条指令地址)保存在堆栈中外,还必须将原主程序中保留在寄存器中中间结果和

标志位的状态保留在堆栈中,直到子程序结束,返回主程序时,再将这些中间结果及标志位状态送回寄存器

和标志寄存器中.

  6502的堆栈地址是0100-01FF,但由于实际上系统也占用了堆栈,所以堆栈指针并不是指向栈底,我们可以

来测试一下.

  进入 NCTOOLS下,A 2000

2000: TSX   堆栈指针低8位送寄存器X
2001: RTS

  然后 G 2000,按 R 查看寄存器状态,结果发现 (X) = B4

  这里说明堆栈指针的值是 01B4,但这是可变的

　

  下面我们来看看堆栈指针随进栈和出栈的变化情况:

A 2000
2000: TSX     //堆栈初始地址低8位送寄存器 X
2001: STX $3000
2004: PHA     //寄存器A的数据压入堆栈
2005: TSX     //把这时堆栈地址低8位送寄存器 X
2006: STX #3001 //结果送地址3001
2009: PHA     //寄存器A的数据压入堆栈
200A: TSX     //把这时堆栈地址低8位送寄存器 X
200B: STX $3002 //结果送地址3002
200E: PLA     //从堆栈中弹出一个数据
200F: TSX     //把这时堆栈地址低8位送寄存器 X
2010: STX $3003 //结果送地址3003
2013: PLA     //从堆栈中弹出一个数据
2014: TSX     //把这时堆栈地址低8位送寄存器 X
2015: STX $3004 //结果送地址3004
2018: RTS

  然后我们 G 2000

  然后 V 3000

  看见地址3000-3004的内容分别是 B4 B3 B2 B3 B4

  说明堆栈指针地址 是 01B4 01B3 01B2 01B3 01B4

  大家可见,当把一个数据进栈后,堆栈指针地址 减 1了,最开始堆栈指针地址是 01B4,后来不就是 01B3了

但把一个数据出栈后,是把最近压入堆栈的数据先出栈,大家可以看到,当又压入一个数据进栈后堆栈指针地址为

01B2,但是当我们弹出一个数据后,堆栈指针为 01B3,说明把最近的一个数据弹出了.

  所以6502堆栈是 遵循 "先进后出"的原则,就好象我们把书一本一本的层叠,但我们拿书的时候,拿的却是最上面

的那本.

我举个例子:

A 2000
2000: LDA $00   //地址 00的内容压入堆栈
2002: PHA
2003: LDA $0A   //地址 0A的内容压入堆栈
2005: PHA
2006: LDA $0D   //地址 0D 的内容压入堆栈
2008: PHA
2009: PLA     //注意:出栈时,先出的是地址0D 的内容,所以是把结果送地址0D,不是地址00
200A: STA $0D
200C: PLA
200D: STA $0A
200F: PLA
2010: STA $00
2012: RTS

　

当调用子程序时,系统自动将子程序 后一指令的地址 - 1 送堆栈,我们举例说明:

子程序从地址2100开始:

A 2100
2100: LDY #$00
2102: LDA #$01   //堆栈指针地址高 8 位 送地址46
2104: STA $46
2106: TSX     //堆栈指针地址低 8 位 送寄存器X
2107: INX     //寄存器X内容加1
2108: STX $45   //送地址 45
210A: LDA ($45), Y //读取目标地址值送地址3000
210C: STA $3000
210F: INC $45   //堆栈指针 低 8位加 1
2111: LDA ($45), Y //读取目标地址值送地址3001
2113: STA $3001     
2116: RTS

主程序从地址2000开始:

A 2000
2000: JSR $2100 //调用子程序 $2100
2003: RTS

　

这里我们 G 2000,V 3000,发现(3000) = 02,(3001) = 20

执行完JSR $2100后,应该执行 地址 2003的指令,为什么是 2002呢?

因为返回后,程序计数器还会自动加 1.

程序在调用 子程序时,会保存 下一指令地址 -1,到堆栈,保存的顺序是 先存地址 高8位

再存地址 低8位.
//addr :代表8位地址   addr16:代表16位地址   data :立即数

[转移指令]

程序在大多数的情况下是按顺序执行的,即依靠程序计数器PC不断自动加1的操作,指示出下一条指令所在地址,这样

计算机就可以按照程序中指令的排列顺序一条接一条的执行下去.

不过在某些条件下,需要改变程序顺序执行的次序,而转入执行另一个地址中存放的指令,这就要依靠转移指令来实现

在6502中有无条件转移和条件转移,无条件转移是无条件的将程序转向另外一个地址,而条件转移是当满足某些条件时

程序才发生转移,比如C=0,C=1,Z=1,Z=0等条件.

无条件转移的跳转步长为整个64K内存,即可以跳转到任意地址

条件跳转指令的跳转步长是有限制的 正跳转127个字节   负跳转128个字节

　

1. JMP--无条件转移指令

符号码格式   指令操作码 寻址方式 
JMP $data16 4C       绝对寻址 
JMP ($data16) 5C       间接寻址 

2. 条件转移指令

符号码格式 指令操作码 寻址方式 指令功能 
BEQ $data16 F0       相对寻址 如果标志位Z=1则转移，否则继续 
BNE $data16 D0       相对寻址 如果标志位Z=0则转移，否则继续 
BCS $data16 B0       相对寻址 如果标志位C=1则转移，否则继续 
BCC $data16 90       相对寻址 如果标志位C=0则转移，否则继续 
BMI $data16 30       相对寻址 如果标志位N=1则转移，否则继续 
BPL $data16 10       相对寻址 如果标志位N=0则转移，否则继续 
BVS $data16 70       相对寻址 如果标志位V=1则转移，否则继续 
BVC $data16 50       相对寻址 如果标志位V=0则转移，否则继续 

这里我重点讲讲用的最多的 BEQ，BNE，BCC，BCS

①BNE 如果标志位 Z = 0则转移，否则继续

  在6502中，要判断两个数是不是相同，就可以使用该指令

  例1： 判断 地址3000与地址3001的内容是不是相同，若相同，则送 01 到地址3002，否则送 00

A 2000
2000:LDA $3000       ;读取地址3000的内容到寄存器A
2003:CMP $3001       ;和地址3001的内容比较,其实就是把地址3000的内容减去地址3001的内容
2006:BNE $200E       ;若Z = 0,说明结果不等于 0 ,那么说明两个地址的内容不同,程序转到地址200E
2008:LDA #$01       ;这里说明Z = 1,那么说明两个数相同
200A:STA $3002
200D:RTS
200E:LDA #$00
2020:STA $3002
2023:RTS

    从上面的程序,我们知道,要比较两个数是不是相同,需要先使用比较指令,然后通过标志寄存器的状态位来判断是不是相同

  ②BEQ 如果标志位 Z = 1,那么就转移,否则继续

    例: 判断 地址3000与地址3001的内容是不是相同，若相同，则送 01 到地址3002，否则送 00

A 2000
2000:LDA $3000
2003:CMP $3001
2006:BEQ $200E
2008:LDA #$00
200A:STA $3002
200D:RTS
200E:LDA #$01
2020:STA $3002
2023:RTS

    该程序和上面的几乎是一样的,大家分析一下吧.

  ③BCC 如果标志为 C = 0,转移,否则继续

    该指令可以用来判断两个数谁大谁小

    例:判断地址3000和地址3001的内容,谁大谁小,若地址3000的内容大,送 01 到地址3002,若地址3001的内容大,送 02到地址3002

如果都是一样大,送00到地址3002

A 2000
2000:LDA $3000         ;读取地址3000的内容到寄存器A
2003:CMP $3001         ;和地址3001的内容比较,其实就是把地址3000的内容减去地址3001的内容
2006:BEQ $2010         ;如果 Z = 1,那么说明相同,转地址2010,送 00 到地址3002
2008:BCC $2016         ;如果 C = 0,那么说明地址 3000的内容 < 地址3001的内容,转地址 2016,送 02到地址3002

200A:LDA #$01           ;这里说明 C = 1,那么说明地址3000的内容 > 地址3001的内容
200C:STA $3002
200F:RTS

2010:LDA #$00
2012:STA $3002
2015:RTS

2016:LDA #$02
2018:STA $3002
201B:RTS

    ④BCS 若 C = 1,则转移,否则继续

    和上面的用法是一样的,大家用该指令完成上面的功能吧!



3. 转移到子程序指令JSR和从主程序返回指令RTS

JSR指令仅仅是 绝对寻址，它的操作码是 20

RTS指令是   隐含寻址，它的操作码是 60     

在程序设计中，如果程序比较大，那么一般是采取模块化设计方法，把一个大的程序分割成若干小程序，然后在主程序调用这些小程序

在6502中就是用JSR这条指令调用子程序的.

转子指令和转移指令的区别在于转移指令控制程序转出后就不再返回了，而转子指令使程序转向子程序后，当子程序被执行完后还要返回

主程序被打断处，实现这个返回是依靠在子程序末尾使用一条子程序返回指令RTS，就可以控制程序自动返回到主程序被打断处

例如：     指令

    .
    .
    .
2000:JSR 2100 //程序执行到这里时，就跳转到地址2100开始执行那里的程序
2003：.
    .
    .
2100:指令
    .
    .
    .
    RTS     //当程序执行到这里后，会自动返回主程序被打断处，即跳转到地址2003那里继续执行
//中断指令

在文曲星内部大量使用了这种指令,该指令占三个字节.

操作符为 INT,机器码为 00

例如 INT $8A01

    INT $C001

那么INT $8A01是执行那里的程序呢?首先8A 是页码,01是字偏移量

我们先转到8A页码,看到下面的数据这里我们先要切换到8A页码,然后根据01,知道执行地址是 4085,因为60EA不算,从8540开始算偏移1

5549 算偏移2,所以 INT $8A02就是执行地址 4955,大家可以自己算.

  这里的 INT $C001就不是转到C0页码了,而是当地址(0A) = 00时,C000-DFFF那里算这里INT $C001 就是执行C059
data16) 5C       间接寻址 

2. 条件转移指令

符号码格式 指令操作码 寻址方式 指令功能 
BEQ $data16 F0       相对寻址 如果标志位Z=1则转移，否则继续 
BNE $data16 D0       相对寻址 如果标志位Z=0则转移，否则继续 